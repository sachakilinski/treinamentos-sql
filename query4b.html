<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Otimiza√ß√£o de Queries: Desafio 4b - Pesquisa de Texto Livre Lenta (BigQuery)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f4f7f6;
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        h1, h2 {
            color: #0056b3;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
            margin-top: 30px;
        }
        h1 {
            text-align: center;
            margin-bottom: 40px;
        }
        pre {
            background-color: #e8f0f7;
            border: 1px solid #cce0f0;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            color: #36454F;
        }
        code {
            font-family: 'Consolas', 'Monaco', monospace;
            background-color: #f0f0f0;
            padding: 2px 5px;
            border-radius: 4px;
        }
        .section {
            margin-bottom: 25px;
        }
        textarea {
            width: 100%;
            height: 150px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.95em;
            resize: vertical;
            box-sizing: border-box;
        }
        button {
            display: block;
            width: 200px;
            padding: 12px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin: 20px auto 0 auto;
        }
        button:hover {
            background-color: #0056b3;
        }
        .feedback {
            margin-top: 30px;
            padding: 20px;
            border-radius: 8px;
            display: none;
        }
        .feedback.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .feedback.failure {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .feedback h3 {
            margin-top: 0;
            color: #0056b3;
        }
        .metric {
            margin-bottom: 5px;
        }
        .highlight {
            font-weight: bold;
            color: #0056b3;
        }
        /* Style for the details/summary elements */
        details {
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        summary {
            padding: 10px 15px;
            cursor: pointer;
            font-weight: bold;
            color: #0056b3;
            list-style: inside;
        }
        details > div {
            padding: 10px 15px 15px 15px;
            border-top: 1px solid #ddd;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Otimiza√ß√£o de Queries: Desafio 4b - Pesquisa de Texto Livre Lenta (BigQuery)</h1>

    <div class="section">
        <h2>Modelo de Dados:</h2>
        <p>Voc√™ gerencia uma tabela no BigQuery que armazena milh√µes de logs de erro di√°rios de diversas aplica√ß√µes. A coluna <code>error_message</code> cont√©m descri√ß√µes detalhadas dos erros.</p>
        <pre><code>CREATE TABLE `project.dataset.error_logs` (
    log_id STRING,
    event_timestamp TIMESTAMP,
    application_name STRING,
    error_level STRING, -- Ex: 'ERROR', 'WARNING', 'INFO'
    error_message STRING, -- Mensagens de erro de texto livre (podem ser longas)
    user_id STRING
    -- ... outras colunas
)
PARTITION BY DATE(event_timestamp); -- Tabela particionada por data
</code></pre>
    </div>

    <div class="section">
        <h2>Query Problem√°tica:</h2>
        <p>A equipe de DevOps precisa encontrar rapidamente logs de erros que contenham frases ou palavras-chave espec√≠ficas dentro da mensagem de erro, independentemente de onde apare√ßam na string. A query atual est√° muito lenta e cara.</p>
        <pre><code>SELECT
    log_id,
    event_timestamp,
    application_name,
    error_message
FROM
    `project.dataset.error_logs`
WHERE
    event_timestamp &gt;= '2024-05-01' AND event_timestamp &lt; '2024-05-02'
    AND REGEXP_CONTAINS(error_message, r'(?i).*database connection failed.*');
    -- A flag (?i) ignora mai√∫sculas/min√∫sculas
</code></pre>
    </div>

    <div class="section">
        <h2>An√°lise de Performance Original (Simulada - BigQuery):</h2>
        <p class="metric"><strong>Tempo de Execu√ß√£o Estimado:</strong> <span class="highlight">35 segundos</span></p>
        <p class="metric"><strong>Dados Escaneados Estimados:</strong> <span class="highlight">800 GB</span> (mesmo com o filtro de data, o regex full-scan na parti√ß√£o √© caro)</p>
        <p class="metric"><strong>Custo Estimado (aprox. $):</strong> <span class="highlight">$4.00</span></p>

        <details>
            <summary>Visualizar Sa√≠da do EXPLAIN (Simulada - BigQuery)</summary>
            <div>
                    <pre><code>
Query Stages:
  Stage 00:
    Input:
      Table: `project.dataset.error_logs`
      Scan: SHARDED_SCAN
      Read Bytes: 800,000,000,000
    Operations:
      - Filter (WHERE clause: event_timestamp >= '2024-05-01' AND event_timestamp < '2024-05-02' AND REGEXP_CONTAINS(error_message, r'(?i).*database connection failed.*'))
    Output:
      Shuffle: None
      Write Bytes: 100 MB
    Slots Used: 800
    Compute Ratio: 0.7
    Input Rows: 5,000,000,000 (total scanned for the day)

Query Stages:
  Stage 01:
    Input:
      Shuffle: None (from Stage 00)
      Read Bytes: 100 MB
    Operations:
      - Final Output
    Output:
      Table: __result__
      Write Bytes: 10 MB
    Slots Used: 50
    Compute Ratio: 0.95
    Input Rows: 50 (final result rows)
                    </code></pre>
            </div>
        </details>

        <details>
            <summary>Visualizar Descri√ß√£o do Plano (Interpreta√ß√£o do EXPLAIN acima)</summary>
            <div>
                <p>A sa√≠da do <code>EXPLAIN</code> mostra que, embora o BigQuery consiga fazer a poda de parti√ß√µes pela coluna <code>event_timestamp</code> (indicado pelo <code>SHARDED_SCAN</code> e o volume de <code>Read Bytes</code> ser menor que o total da tabela), a opera√ß√£o de <code>REGEXP_CONTAINS</code> na coluna <code>error_message</code> ainda est√° causando um **escaneamento completo da coluna de texto dentro da parti√ß√£o selecionada**. Isso √© computacionalmente intensivo e caro, pois o BigQuery precisa ler e processar cada string na coluna `error_message` para aplicar a express√£o regular.</p>
                <p>A natureza do padr√£o `.*termo.*` (com wildcards em ambos os lados) impede qualquer otimiza√ß√£o baseada em prefixo ou dicion√°rio, for√ßando um scan completo das strings na mem√≥ria, mesmo que o restante da query seja restrito por parti√ß√µes.</p>
            </div>
        </details>
    </div>

    <div class="section">
        <h2>Sua Miss√£o:</h2>
        <p>Analise a query, o modelo de dados e a sa√≠da do <code>EXPLAIN</code>. Identifique o(s) problema(s) de performance causado(s) pela pesquisa de texto livre e o(s) gargalo(s) principal(is) no contexto do BigQuery. Proponha uma ou mais instru√ß√µes SQL que otimizem drasticamente a performance desta query, focando nas capacidades de busca de texto do BigQuery.</p>
    </div>

    <div class="section">
        <h3>Caixa de Texto para Solu√ß√£o:</h3>
        <textarea id="solutionInput" placeholder="-- Insira sua solu√ß√£o SQL aqui (pode ser uma nova query, comando de CREATE SEARCH INDEX, etc.)
-- Pense em como o BigQuery pode otimizar buscas de texto livre de forma eficiente."></textarea>
        <button id="submitButton">Submeter Melhoria</button>
    </div>

    <div id="feedback" class="feedback">
    </div>

    <details class="section">
        <summary>Visualizar Solu√ß√£o Sugerida (Desafio 4b)</summary>
        <div>
            <h3>Solu√ß√£o de √çndice (Search Index):</h3>
            <pre><code>-- 1. Criar um Search Index na coluna error_message
CREATE SEARCH INDEX `error_message_search_index`
ON `project.dataset.error_logs`(error_message);

-- A cria√ß√£o do √≠ndice leva um tempo dependendo do tamanho da tabela.
-- Para manuten√ß√£o, o BigQuery gerencia automaticamente.
</code></pre>
            <h3>Query Otimizada:</h3>
            <pre><code>SELECT
    log_id,
    event_timestamp,
    application_name,
    error_message
FROM
    `project.dataset.error_logs`
WHERE
    event_timestamp &gt;= '2024-05-01' AND event_timestamp &lt; '2024-05-02'
    AND SEARCH(error_message, 'database connection failed');
-- A fun√ß√£o SEARCH() √© otimizada para usar Search Indexes.
-- Ela ignora mai√∫sculas/min√∫sculas e pode lidar com m√∫ltiplos termos.
</code></pre>
            <h4>Explica√ß√£o da Solu√ß√£o:</h4>
            <p>O problema principal era a inefici√™ncia do <code>REGEXP_CONTAINS</code> com wildcards em ambos os lados, que for√ßa uma varredura completa da coluna de texto dentro de cada parti√ß√£o relevante. Para pesquisas de texto livre em grandes volumes de dados no BigQuery, a solu√ß√£o ideal √© usar o recurso de **Search Indexes**.</p>
            <p>A solu√ß√£o envolve os seguintes passos:</p>
            <ul>
                <li><strong><code>CREATE SEARCH INDEX</code>:</strong> Este comando cria um √≠ndice de pesquisa especializado na coluna <code>error_message</code>. Diferente de uma varredura de express√£o regular, um Search Index √© um tipo de √≠ndice invertido. Ele permite que o BigQuery localize rapidamente as linhas que cont√™m os termos de busca sem precisar escanear e processar a coluna textual inteira.</li>
                <li><strong>Fun√ß√£o <code>SEARCH()</code>:</strong> Ao substituir <code>REGEXP_CONTAINS</code> por <code>SEARCH()</code>, voc√™ instrui o BigQuery a utilizar o Search Index rec√©m-criado. Esta fun√ß√£o √© otimizada para trabalhar com os Search Indexes, sendo muito mais eficiente para consultas de texto livre. Ela j√° lida com a insensibilidade a mai√∫sculas/min√∫sculas e a busca de substrings.</li>
                <li><strong>Otimiza√ß√£o Combinada:</strong> O BigQuery agora pode primeiro podar as parti√ß√µes por <code>event_timestamp</code> (o que j√° estava acontecendo), e ent√£o, dentro da parti√ß√£o relevante, usar o **Search Index** para encontrar as mensagens de erro. Isso resulta em um `INDEX_SCAN_ON_SEARCH_INDEX` altamente eficiente, reduzindo drasticamente a quantidade de dados lidos e processados, impactando diretamente o tempo de execu√ß√£o e o custo.</li>
            </ul>
            <p>Esta abordagem √© a mais eficiente e recomendada para pesquisa de texto livre escal√°vel no BigQuery, transformando uma query lenta e cara em uma opera√ß√£o r√°pida e de baixo custo.</p>
        </div>
    </details>
</div>

<script>
    document.getElementById('submitButton').addEventListener('click', function() {
        const solution = document.getElementById('solutionInput').value.trim();
        const feedbackDiv = document.getElementById('feedback');
        let feedbackHtml = '';
        let isSuccess = false;

        const submittedSolutionCleaned = solution.toLowerCase().replace(/\s+/g, ' ').trim();

        // Check for key elements of a BigQuery Search Index solution
        const hasCreateIndex = submittedSolutionCleaned.includes("create search index");
        const hasSearchFunction = submittedSolutionCleaned.includes("search(");
        const targetsErrorMessage = submittedSolutionCleaned.includes("error_message");

        // For a successful submission, we need both index creation and query change
        if (hasCreateIndex && hasSearchFunction && targetsErrorMessage) {
            isSuccess = true;
            const optimizedExplain = `
Query Stages:
Stage 00:
Input:
  Table: \`project.dataset.error_logs\`
  Scan: INDEX_SCAN_ON_SEARCH_INDEX
  Read Bytes: 5,000,000,000
Operations:
  - Filter (WHERE clause: event_timestamp >= '2024-05-01' AND event_timestamp < '2024-05-02' AND SEARCH(error_message, 'database connection failed'))
Output:
  Shuffle: None
  Write Bytes: 50 MB
Slots Used: 50
Compute Ratio: 0.98
Input Rows: 1000 (total rows identified by index)

Query Stages:
Stage 01:
Input:
  Shuffle: None (from Stage 00)
  Read Bytes: 50 MB
Operations:
  - Final Output
Output:
  Table: __result__
  Write Bytes: 10 MB
Slots Used: 10
Compute Ratio: 0.99
Input Rows: 50 (final result rows)
            `;
            const optimizedPlanDescription = `Voc√™ identificou a solu√ß√£o ideal para pesquisas de texto livre no BigQuery: a utiliza√ß√£o de **Search Indexes** e a fun√ß√£o \`SEARCH()\` correspondente.
<ul>
<li>**\`CREATE SEARCH INDEX\`:** Este comando cria um √≠ndice de pesquisa especializado na coluna \`error_message\`. Diferente de uma varredura \`REGEXP_CONTAINS\`, um Search Index √© um √≠ndice invertido, permitindo que o BigQuery localize rapidamente as linhas que cont√™m os termos de busca sem precisar escanear a coluna inteira.</li>
<li>**Fun√ß√£o \`SEARCH()\`:** Ao substituir \`REGEXP_CONTAINS\` por \`SEARCH()\`, voc√™ instrui o BigQuery a utilizar o Search Index rec√©m-criado. Esta fun√ß√£o √© otimizada para trabalhar com os Search Indexes.</li>
<li>**Otimiza√ß√£o Combinada:** O BigQuery agora pode primeiro podar as parti√ß√µes por \`event_timestamp\` (como antes), e ent√£o, dentro da parti√ß√£o relevante, usar o **Search Index** para encontrar as mensagens de erro, resultando em um \`INDEX_SCAN_ON_SEARCH_INDEX\` altamente eficiente. Isso reduz drasticamente a quantidade de dados lidos e processados, impactando diretamente o tempo de execu√ß√£o e o custo.</li>
</ul>
Esta abordagem √© a mais eficiente para pesquisa de texto livre escal√°vel no BigQuery, transformando uma query lenta e cara em uma opera√ß√£o r√°pida e de baixo custo.`;

            feedbackHtml = `
                <h3>üéâ SUCESSO! üéâ</h3>
                <p><strong>An√°lise da Sua Solu√ß√£o:</strong></p>
                <p class="metric"><strong>Tempo de Execu√ß√£o Estimado (AP√ìS SUA OTIMIZA√á√ÉO):</strong> <span class="highlight">2 segundos</span> (redu√ß√£o de 94.3%)</p>
                <p class="metric"><strong>Dados Escaneados Estimados:</strong> <span class="highlight">5 GB</span> (redu√ß√£o de 99.3%)</p>
                <p class="metric"><strong>Custo Estimado (aprox. $):</strong> <span class="highlight">$0.025</span> (redu√ß√£o de 99.3%)</p>

                <details open>
                    <summary>Visualizar Sa√≠da do EXPLAIN (AP√ìS SUA OTIMIZA√á√ÉO - Simulada)</summary>
                    <div>
                        <pre><code>${optimizedExplain}</code></pre>
                    </div>
                </details>

                <details open>
                    <summary>Visualizar Descri√ß√£o do Plano (Interpreta√ß√£o do EXPLAIN acima)</summary>
                    <div>
                        <p>${optimizedPlanDescription}</p>
                    </div>
                </details>

                <p><strong>Parab√©ns!</strong> Voc√™ dominou o desafio de otimiza√ß√£o de pesquisas de texto livre no BigQuery!</p>
            `;
            feedbackDiv.className = 'feedback success';
        } else {
            feedbackHtml = `
                <h3>üòî Tente Novamente! üòî</h3>
                <p>Sua solu√ß√£o ainda n√£o atingiu o n√≠vel de otimiza√ß√£o esperado ou n√£o est√° no formato correto para este desafio.</p>
                <p>Revise a sa√≠da do <code>EXPLAIN</code> original. O principal indicador de problema √© o alto volume de <strong><code>Read Bytes</code></strong> mesmo com o <code>SHARDED_SCAN</code>, indicando que a fun√ß√£o de texto livre est√° varrendo muitos dados.</p>
                <p>Pense em como o BigQuery otimiza as pesquisas de texto livre em grandes volumes de dados. H√° uma funcionalidade espec√≠fica para isso que envolve um tipo especial de √≠ndice e uma fun√ß√£o de busca dedicada.</p>
            `;
            feedbackDiv.className = 'feedback failure';
        }

        feedbackDiv.innerHTML = feedbackHtml;
        feedbackDiv.style.display = 'block';
        feedbackDiv.scrollIntoView({ behavior: 'smooth' });
    });
</script>
</body>
</html>