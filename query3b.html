<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Otimização de Queries: Desafio 3b - Escaneamento Excessivo de Dados (PostgreSQL)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f4f7f6;
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        h1, h2 {
            color: #0056b3;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
            margin-top: 30px;
        }
        h1 {
            text-align: center;
            margin-bottom: 40px;
        }
        pre {
            background-color: #e8f0f7;
            border: 1px solid #cce0f0;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            color: #36454F;
        }
        code {
            font-family: 'Consolas', 'Monaco', monospace;
            background-color: #f0f0f0;
            padding: 2px 5px;
            border-radius: 4px;
        }
        .section {
            margin-bottom: 25px;
        }
        textarea {
            width: 100%;
            height: 150px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.95em;
            resize: vertical;
            box-sizing: border-box;
        }
        button {
            display: block;
            width: 200px;
            padding: 12px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin: 20px auto 0 auto;
        }
        button:hover {
            background-color: #0056b3;
        }
        .feedback {
            margin-top: 30px;
            padding: 20px;
            border-radius: 8px;
            display: none;
        }
        .feedback.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .feedback.failure {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .feedback h3 {
            margin-top: 0;
            color: #0056b3;
        }
        .metric {
            margin-bottom: 5px;
        }
        .highlight {
            font-weight: bold;
            color: #0056b3;
        }
        /* Style for the details/summary elements */
        details {
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        summary {
            padding: 10px 15px;
            cursor: pointer;
            font-weight: bold;
            color: #0056b3;
            list-style: inside;
        }
        details > div {
            padding: 10px 15px 15px 15px;
            border-top: 1px solid #ddd;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Otimização de Queries: Desafio 3b - Escaneamento Excessivo de Dados (PostgreSQL)</h1>

    <div class="section">
        <h2>Modelo de Dados:</h2>
        <p>Você gerencia uma grande tabela de transações financeiras no PostgreSQL.</p>
        <pre><code>CREATE TABLE transacoes (
    transacao_id SERIAL PRIMARY KEY,
    conta_id INT NOT NULL,
    valor DECIMAL(12, 2) NOT NULL,
    data_transacao TIMESTAMP NOT NULL,
    tipo_transacao VARCHAR(50) NOT NULL, -- Ex: 'COMPRA', 'VENDA', 'DEPOSITO'
    status_transacao VARCHAR(50) NOT NULL, -- Ex: 'APROVADA', 'PENDENTE', 'CANCELADA'
    -- ... outras colunas
);</code></pre>
        <p><strong>Observações Importantes:</strong></p>
        <ul>
            <li>A tabela <code>transacoes</code> tem <strong>dezenas de milhões de registros</strong>.</li>
            <li>Atualmente, **não há índices personalizados** nesta tabela, apenas a PRIMARY KEY em `transacao_id`.</li>
        </ul>
    </div>

    <div class="section">
        <h2>Query Problemática:</h2>
        <p>A equipe de análise de fraude precisa listar todas as transações de `COMPRA` que foram realizadas com um valor acima de `1000.00` no último ano. A query está demorando muito para retornar os resultados.</p>
        <pre><code>SELECT
    transacao_id,
    data_transacao,
    valor,
    conta_id
FROM
    transacoes
WHERE
    tipo_transacao = 'COMPRA'
    AND valor > 1000.00
    AND data_transacao >= NOW() - INTERVAL '1 year'
ORDER BY
    data_transacao DESC;
</code></pre>
    </div>

    <div class="section">
        <h2>Análise de Performance Original (Simulada - PostgreSQL):</h2>
        <p class="metric"><strong>Tempo de Execução Estimado:</strong> <span class="highlight">28 segundos</span></p>
        <p class="metric"><strong>Recursos Consumidos (I/O Disk):</strong> <span class="highlight">15 GB lidos</span></p>
        <p class="metric"><strong>Uso de Memória:</strong> <span class="highlight">Muito Alto</span></p>

        <details>
            <summary>Visualizar Saída do EXPLAIN ANALYZE (Simulada)</summary>
            <div>
                    <pre><code>
                                            QUERY PLAN
--------------------------------------------------------------------------------------------------
 Sort  (cost=543210.00..543215.00 rows=20000 width=60) (actual time=27800.123..27950.456 rows=18500 loops=1)
   Sort Key: data_transacao DESC
   Sort Method: external merge  Disk: 80000KB
   ->  Seq Scan on transacoes  (cost=0.00..543123.45 rows=20000 width=60) (actual time=0.080..27500.789 rows=18500 loops=1)
         Filter: ((tipo_transacao = 'COMPRA'::text) AND (valor > 1000.00) AND (data_transacao >= (now() - '1 year'::interval)))
         Rows Removed by Filter: 80000000
(6 rows)
                    </code></pre>
            </div>
        </details>

        <details>
            <summary>Visualizar Descrição do Plano (Interpretação do EXPLAIN ANALYZE)</summary>
            <div>
                <p>O <code>EXPLAIN ANALYZE</code> mostra que o PostgreSQL está realizando um **<code>Seq Scan on transacoes</code>**, o que significa que ele está lendo a **tabela inteira** (dezenas de milhões de registros) do disco para encontrar as transações que correspondem aos seus filtros. Isso é extremamente ineficiente para uma tabela tão grande e é a principal causa do alto I/O e tempo de execução.</p>
                <p>Após o `Seq Scan` e a aplicação dos filtros, há uma operação de **<code>Sort Method: external merge Disk</code>**. Isso indica que o conjunto de resultados (mesmo após os filtros) ainda é grande demais para ser ordenado na memória RAM disponível, forçando o PostgreSQL a usar o disco para a ordenação, o que é muito mais lento.</p>
                <p>Em resumo, a ausência de um índice adequado está forçando o banco a varrer todos os dados da tabela, e a ordenar os resultados em disco, consumindo tempo e muitos recursos.</p>
            </div>
        </details>
    </div>

    <div class="section">
        <h2>Sua Missão:</h2>
        <p>Analise a query, o modelo de dados e a saída do <code>EXPLAIN ANALYZE</code>. Identifique o(s) problema(s) de performance e o(s) gargalo(s) principal(is). Proponha uma ou mais instruções SQL que otimizem a performance desta query, visando reduzir drasticamente os dados escaneados e o tempo de execução.</p>
    </div>

    <div class="section">
        <h3>Caixa de Texto para Solução:</h3>
        <textarea id="solutionInput" placeholder="-- Insira sua solução SQL aqui (pode ser uma query otimizada, criação de índices, etc.)"></textarea>
        <button id="submitButton">Submeter Melhoria</button>
    </div>

    <div id="feedback" class="feedback">
    </div>

    <details class="section">
        <summary>Visualizar Solução Sugerida (Desafio 3b)</summary>
        <div>
            <h3>Solução de Índice:</h3>
            <pre><code>CREATE INDEX idx_transacoes_tipo_data_valor ON transacoes (tipo_transacao, data_transacao DESC, valor);</code></pre>
            <h4>Explicação da Solução:</h4>
            <p>O problema central é o **<code>Seq Scan</code>** e o **<code>Sort</code> em disco**, ambos causados pela falta de um índice otimizado para as condições do <code>WHERE</code> e do <code>ORDER BY</code>.</p>
            <p>A criação de um **índice composto** como <code>(tipo_transacao, data_transacao DESC, valor)</code> é a solução mais eficaz:</p>
            <ul>
                <li>**<code>tipo_transacao</code>:** É a primeira coluna e a condição de igualdade (<code>= 'COMPRA'</code>). Isso permite que o PostgreSQL use o índice para ir diretamente aos blocos de dados que contêm transações de `COMPRA`, evitando um `Seq Scan` massivo de toda a tabela.</li>
                <li>**<code>data_transacao DESC</code>:** Esta coluna é a segunda no índice e corresponde à condição de `range` (último ano) e, crucialmente, à **ordem de saída (<code>ORDER BY data_transacao DESC</code>)**. Ao incluir a ordenação `DESC` diretamente no índice, o PostgreSQL pode ler os dados já na ordem desejada, eliminando a cara operação de `Sort` em disco.</li>
                <li>**<code>valor</code>:** Embora `valor` seja a terceira coluna, sua inclusão no índice torna-o um **"covering index"** para a condição `valor > 1000.00` (ou ajuda na seletividade se `tipo_transacao` e `data_transacao` retornarem muitos resultados). Idealmente, para um filtro de range, seria a última. Se o índice também fosse um **"covering index"** para as colunas selecionadas (`transacao_id`, `data_transacao`, `valor`, `conta_id`) com uma cláusula `INCLUDE`, o PostgreSQL sequer precisaria acessar a tabela principal (Heap) para obter esses dados, mas o índice proposto já resolve o problema principal.</li>
            </ul>
            <p>Com este índice, o PostgreSQL pode realizar um **<code>Index Scan</code>** ou **<code>Bitmap Index Scan</code>** eficiente, lendo apenas os dados relevantes e entregando-os já ordenados, transformando radicalmente o tempo de execução e o consumo de recursos.</p>
        </div>
    </details>
</div>

<script>
    document.getElementById('submitButton').addEventListener('click', function() {
        const solution = document.getElementById('solutionInput').value.trim();
        const feedbackDiv = document.getElementById('feedback');
        let feedbackHtml = '';
        let isSuccess = false;

        const submittedSolutionCleaned = solution.toLowerCase().replace(/\s+/g, ' ').trim();

        const hasCreateIndex = submittedSolutionCleaned.includes("create index");
        const hasTipoTransacao = submittedSolutionCleaned.includes("tipo_transacao");
        const hasDataTransacaoDesc = submittedSolutionCleaned.includes("data_transacao desc");
        const hasValor = submittedSolutionCleaned.includes("valor");

        // Check for correct order for a compound index that covers filters and order by
        const idxTipo = submittedSolutionCleaned.indexOf("tipo_transacao");
        const idxDataDesc = submittedSolutionCleaned.indexOf("data_transacao desc");
        const idxValor = submittedSolutionCleaned.indexOf("valor");

        const isOrderCorrect = (idxTipo !== -1 && idxDataDesc !== -1 && idxValor !== -1) &&
                               (idxTipo < idxDataDesc && idxDataDesc < idxValor);

        // For a simpler check for the challenge, we accept if all components are there and in a reasonable order
        const isSolutionEffective = hasCreateIndex && hasTipoTransacao && hasDataTransacaoDesc && hasValor && isOrderCorrect;

        if (isSolutionEffective) {
            isSuccess = true;
            const optimizedExplain = `
                                        QUERY PLAN
--------------------------------------------------------------------------------------------------
Index Scan Backward using idx_transacoes_tipo_data_valor on transacoes  (cost=0.43..20.50 rows=18500 width=60) (actual time=0.080..0.145 rows=18500 loops=1)
Index Cond: ((tipo_transacao = 'COMPRA'::text) AND (data_transacao >= (now() - '1 year'::interval)) AND (valor > 1000.00))
(2 rows)
            `;
            const optimizedPlanDescription = `Você identificou e resolveu o problema de escaneamento excessivo! O <code>EXPLAIN ANALYZE</code> original mostrava um caro <code>Seq Scan</code> e um <code>Sort</code> em disco.

Sua solução de criar um **índice composto** como <code>(tipo_transacao, data_transacao DESC, valor)</code> é ideal.
<ul>
<li>Ele permite que o PostgreSQL use um **<code>Index Scan Backward</code>** para filtrar diretamente por <code>tipo_transacao</code> e <code>data_transacao</code>, lendo apenas os dados relevantes.</li>
<li>A inclusão de <code>data_transacao DESC</code> no índice também satisfaz a cláusula <code>ORDER BY</code> diretamente, eliminando completamente a necessidade de uma operação de <code>Sort</code> (especialmente o lento "external merge Disk").</li>
<li>A coluna <code>valor</code> também é coberta pelo índice, ajudando a filtrar ainda mais cedo ou garantindo que o índice seja um "covering index" para parte das colunas da query.</li>
</ul>
Isso resulta em um plano de execução extremamente eficiente, transformando o tempo de resposta da query!`;

            feedbackHtml = `
                <h3>🎉 SUCESSO! 🎉</h3>
                <p><strong>Análise da Sua Solução:</strong></p>
                <p class="metric"><strong>Tempo de Execução Estimado (APÓS SUA OTIMIZAÇÃO):</strong> <span class="highlight">0.18 segundos</span> (redução de 99.3%)</p>
                <p class="metric"><strong>Recursos Consumidos (I/O Disk):</strong> <span class="highlight">150 KB lidos</span> (redução de 99.9%)</p>
                <p class="metric"><strong>Uso de Memória:</strong> <span class="highlight">Baixo</span></p>

                <details open>
                    <summary>Visualizar Saída do EXPLAIN ANALYZE (APÓS SUA OTIMIZAÇÃO - Simulada)</summary>
                    <div>
                        <pre><code>${optimizedExplain}</code></pre>
                    </div>
                </details>

                <details open>
                    <summary>Visualizar Descrição do Plano (Interpretação do EXPLAIN ANALYZE)</summary>
                    <div>
                        <p>${optimizedPlanDescription}</p>
                    </div>
                </details>

                <p><strong>Parabéns!</strong> Você dominou o desafio de otimização de escaneamento excessivo de dados no PostgreSQL!</p>
            `;
            feedbackDiv.className = 'feedback success';
        } else {
            feedbackHtml = `
                <h3>😔 Tente Novamente! 😔</h3>
                <p>Sua solução ainda não atingiu o nível de otimização esperado ou não está no formato correto para este desafio.</p>
                <p>Reveja a saída do <code>EXPLAIN ANALYZE</code> original. O principal indicador de problema é o <strong><code>Seq Scan on transacoes</code></strong>, que significa que o PostgreSQL está lendo a tabela inteira. Além disso, observe o <strong><code>Sort Method: external merge Disk</code></strong>, que indica que a ordenação está sendo feita em disco.</p>
                <p>Pense em como você pode ajudar o PostgreSQL a evitar o `Seq Scan` e o `Sort` em disco, considerando as colunas usadas nas cláusulas `WHERE` e `ORDER BY`.</p>
            `;
            feedbackDiv.className = 'feedback failure';
        }

        feedbackDiv.innerHTML = feedbackHtml;
        feedbackDiv.style.display = 'block';
        feedbackDiv.scrollIntoView({ behavior: 'smooth' });
    });
</script>
</body>
</html>