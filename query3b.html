<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Otimiza√ß√£o de Queries: Desafio 3b - Escaneamento Excessivo de Dados (PostgreSQL)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f4f7f6;
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        h1, h2 {
            color: #0056b3;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
            margin-top: 30px;
        }
        h1 {
            text-align: center;
            margin-bottom: 40px;
        }
        pre {
            background-color: #e8f0f7;
            border: 1px solid #cce0f0;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            color: #36454F;
        }
        code {
            font-family: 'Consolas', 'Monaco', monospace;
            background-color: #f0f0f0;
            padding: 2px 5px;
            border-radius: 4px;
        }
        .section {
            margin-bottom: 25px;
        }
        textarea {
            width: 100%;
            height: 150px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.95em;
            resize: vertical;
            box-sizing: border-box;
        }
        button {
            display: block;
            width: 200px;
            padding: 12px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin: 20px auto 0 auto;
        }
        button:hover {
            background-color: #0056b3;
        }
        .feedback {
            margin-top: 30px;
            padding: 20px;
            border-radius: 8px;
            display: none;
        }
        .feedback.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .feedback.failure {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .feedback h3 {
            margin-top: 0;
            color: #0056b3;
        }
        .metric {
            margin-bottom: 5px;
        }
        .highlight {
            font-weight: bold;
            color: #0056b3;
        }
        /* Style for the details/summary elements */
        details {
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        summary {
            padding: 10px 15px;
            cursor: pointer;
            font-weight: bold;
            color: #0056b3;
            list-style: inside;
        }
        details > div {
            padding: 10px 15px 15px 15px;
            border-top: 1px solid #ddd;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Otimiza√ß√£o de Queries: Desafio 3b - Escaneamento Excessivo de Dados (PostgreSQL)</h1>

    <div class="section">
        <h2>Modelo de Dados:</h2>
        <p>Voc√™ gerencia uma grande tabela de transa√ß√µes financeiras no PostgreSQL.</p>
        <pre><code>CREATE TABLE transacoes (
    transacao_id SERIAL PRIMARY KEY,
    conta_id INT NOT NULL,
    valor DECIMAL(12, 2) NOT NULL,
    data_transacao TIMESTAMP NOT NULL,
    tipo_transacao VARCHAR(50) NOT NULL, -- Ex: 'COMPRA', 'VENDA', 'DEPOSITO'
    status_transacao VARCHAR(50) NOT NULL, -- Ex: 'APROVADA', 'PENDENTE', 'CANCELADA'
    -- ... outras colunas
);</code></pre>
        <p><strong>Observa√ß√µes Importantes:</strong></p>
        <ul>
            <li>A tabela <code>transacoes</code> tem <strong>dezenas de milh√µes de registros</strong>.</li>
            <li>Atualmente, **n√£o h√° √≠ndices personalizados** nesta tabela, apenas a PRIMARY KEY em `transacao_id`.</li>
        </ul>
    </div>

    <div class="section">
        <h2>Query Problem√°tica:</h2>
        <p>A equipe de an√°lise de fraude precisa listar todas as transa√ß√µes de `COMPRA` que foram realizadas com um valor acima de `1000.00` no √∫ltimo ano. A query est√° demorando muito para retornar os resultados.</p>
        <pre><code>SELECT
    transacao_id,
    data_transacao,
    valor,
    conta_id
FROM
    transacoes
WHERE
    tipo_transacao = 'COMPRA'
    AND valor > 1000.00
    AND data_transacao >= NOW() - INTERVAL '1 year'
ORDER BY
    data_transacao DESC;
</code></pre>
    </div>

    <div class="section">
        <h2>An√°lise de Performance Original (Simulada - PostgreSQL):</h2>
        <p class="metric"><strong>Tempo de Execu√ß√£o Estimado:</strong> <span class="highlight">28 segundos</span></p>
        <p class="metric"><strong>Recursos Consumidos (I/O Disk):</strong> <span class="highlight">15 GB lidos</span></p>
        <p class="metric"><strong>Uso de Mem√≥ria:</strong> <span class="highlight">Muito Alto</span></p>

        <details>
            <summary>Visualizar Sa√≠da do EXPLAIN ANALYZE (Simulada)</summary>
            <div>
                    <pre><code>
                                            QUERY PLAN
--------------------------------------------------------------------------------------------------
 Sort  (cost=543210.00..543215.00 rows=20000 width=60) (actual time=27800.123..27950.456 rows=18500 loops=1)
   Sort Key: data_transacao DESC
   Sort Method: external merge  Disk: 80000KB
   ->  Seq Scan on transacoes  (cost=0.00..543123.45 rows=20000 width=60) (actual time=0.080..27500.789 rows=18500 loops=1)
         Filter: ((tipo_transacao = 'COMPRA'::text) AND (valor > 1000.00) AND (data_transacao >= (now() - '1 year'::interval)))
         Rows Removed by Filter: 80000000
(6 rows)
                    </code></pre>
            </div>
        </details>

        <details>
            <summary>Visualizar Descri√ß√£o do Plano (Interpreta√ß√£o do EXPLAIN ANALYZE)</summary>
            <div>
                <p>O <code>EXPLAIN ANALYZE</code> mostra que o PostgreSQL est√° realizando um **<code>Seq Scan on transacoes</code>**, o que significa que ele est√° lendo a **tabela inteira** (dezenas de milh√µes de registros) do disco para encontrar as transa√ß√µes que correspondem aos seus filtros. Isso √© extremamente ineficiente para uma tabela t√£o grande e √© a principal causa do alto I/O e tempo de execu√ß√£o.</p>
                <p>Ap√≥s o `Seq Scan` e a aplica√ß√£o dos filtros, h√° uma opera√ß√£o de **<code>Sort Method: external merge Disk</code>**. Isso indica que o conjunto de resultados (mesmo ap√≥s os filtros) ainda √© grande demais para ser ordenado na mem√≥ria RAM dispon√≠vel, for√ßando o PostgreSQL a usar o disco para a ordena√ß√£o, o que √© muito mais lento.</p>
                <p>Em resumo, a aus√™ncia de um √≠ndice adequado est√° for√ßando o banco a varrer todos os dados da tabela, e a ordenar os resultados em disco, consumindo tempo e muitos recursos.</p>
            </div>
        </details>
    </div>

    <div class="section">
        <h2>Sua Miss√£o:</h2>
        <p>Analise a query, o modelo de dados e a sa√≠da do <code>EXPLAIN ANALYZE</code>. Identifique o(s) problema(s) de performance e o(s) gargalo(s) principal(is). Proponha uma ou mais instru√ß√µes SQL que otimizem a performance desta query, visando reduzir drasticamente os dados escaneados e o tempo de execu√ß√£o.</p>
    </div>

    <div class="section">
        <h3>Caixa de Texto para Solu√ß√£o:</h3>
        <textarea id="solutionInput" placeholder="-- Insira sua solu√ß√£o SQL aqui (pode ser uma query otimizada, cria√ß√£o de √≠ndices, etc.)"></textarea>
        <button id="submitButton">Submeter Melhoria</button>
    </div>

    <div id="feedback" class="feedback">
    </div>

    <details class="section">
        <summary>Visualizar Solu√ß√£o Sugerida (Desafio 3b)</summary>
        <div>
            <h3>Solu√ß√£o de √çndice:</h3>
            <pre><code>CREATE INDEX idx_transacoes_tipo_data_valor ON transacoes (tipo_transacao, data_transacao DESC, valor);</code></pre>
            <h4>Explica√ß√£o da Solu√ß√£o:</h4>
            <p>O problema central √© o **<code>Seq Scan</code>** e o **<code>Sort</code> em disco**, ambos causados pela falta de um √≠ndice otimizado para as condi√ß√µes do <code>WHERE</code> e do <code>ORDER BY</code>.</p>
            <p>A cria√ß√£o de um **√≠ndice composto** como <code>(tipo_transacao, data_transacao DESC, valor)</code> √© a solu√ß√£o mais eficaz:</p>
            <ul>
                <li>**<code>tipo_transacao</code>:** √â a primeira coluna e a condi√ß√£o de igualdade (<code>= 'COMPRA'</code>). Isso permite que o PostgreSQL use o √≠ndice para ir diretamente aos blocos de dados que cont√™m transa√ß√µes de `COMPRA`, evitando um `Seq Scan` massivo de toda a tabela.</li>
                <li>**<code>data_transacao DESC</code>:** Esta coluna √© a segunda no √≠ndice e corresponde √† condi√ß√£o de `range` (√∫ltimo ano) e, crucialmente, √† **ordem de sa√≠da (<code>ORDER BY data_transacao DESC</code>)**. Ao incluir a ordena√ß√£o `DESC` diretamente no √≠ndice, o PostgreSQL pode ler os dados j√° na ordem desejada, eliminando a cara opera√ß√£o de `Sort` em disco.</li>
                <li>**<code>valor</code>:** Embora `valor` seja a terceira coluna, sua inclus√£o no √≠ndice torna-o um **"covering index"** para a condi√ß√£o `valor > 1000.00` (ou ajuda na seletividade se `tipo_transacao` e `data_transacao` retornarem muitos resultados). Idealmente, para um filtro de range, seria a √∫ltima. Se o √≠ndice tamb√©m fosse um **"covering index"** para as colunas selecionadas (`transacao_id`, `data_transacao`, `valor`, `conta_id`) com uma cl√°usula `INCLUDE`, o PostgreSQL sequer precisaria acessar a tabela principal (Heap) para obter esses dados, mas o √≠ndice proposto j√° resolve o problema principal.</li>
            </ul>
            <p>Com este √≠ndice, o PostgreSQL pode realizar um **<code>Index Scan</code>** ou **<code>Bitmap Index Scan</code>** eficiente, lendo apenas os dados relevantes e entregando-os j√° ordenados, transformando radicalmente o tempo de execu√ß√£o e o consumo de recursos.</p>
        </div>
    </details>
</div>

<script>
    document.getElementById('submitButton').addEventListener('click', function() {
        const solution = document.getElementById('solutionInput').value.trim();
        const feedbackDiv = document.getElementById('feedback');
        let feedbackHtml = '';
        let isSuccess = false;

        const submittedSolutionCleaned = solution.toLowerCase().replace(/\s+/g, ' ').trim();

        const hasCreateIndex = submittedSolutionCleaned.includes("create index");
        const hasTipoTransacao = submittedSolutionCleaned.includes("tipo_transacao");
        const hasDataTransacaoDesc = submittedSolutionCleaned.includes("data_transacao desc");
        const hasValor = submittedSolutionCleaned.includes("valor");

        // Check for correct order for a compound index that covers filters and order by
        const idxTipo = submittedSolutionCleaned.indexOf("tipo_transacao");
        const idxDataDesc = submittedSolutionCleaned.indexOf("data_transacao desc");
        const idxValor = submittedSolutionCleaned.indexOf("valor");

        const isOrderCorrect = (idxTipo !== -1 && idxDataDesc !== -1 && idxValor !== -1) &&
                               (idxTipo < idxDataDesc && idxDataDesc < idxValor);

        // For a simpler check for the challenge, we accept if all components are there and in a reasonable order
        const isSolutionEffective = hasCreateIndex && hasTipoTransacao && hasDataTransacaoDesc && hasValor && isOrderCorrect;

        if (isSolutionEffective) {
            isSuccess = true;
            const optimizedExplain = `
                                        QUERY PLAN
--------------------------------------------------------------------------------------------------
Index Scan Backward using idx_transacoes_tipo_data_valor on transacoes  (cost=0.43..20.50 rows=18500 width=60) (actual time=0.080..0.145 rows=18500 loops=1)
Index Cond: ((tipo_transacao = 'COMPRA'::text) AND (data_transacao >= (now() - '1 year'::interval)) AND (valor > 1000.00))
(2 rows)
            `;
            const optimizedPlanDescription = `Voc√™ identificou e resolveu o problema de escaneamento excessivo! O <code>EXPLAIN ANALYZE</code> original mostrava um caro <code>Seq Scan</code> e um <code>Sort</code> em disco.

Sua solu√ß√£o de criar um **√≠ndice composto** como <code>(tipo_transacao, data_transacao DESC, valor)</code> √© ideal.
<ul>
<li>Ele permite que o PostgreSQL use um **<code>Index Scan Backward</code>** para filtrar diretamente por <code>tipo_transacao</code> e <code>data_transacao</code>, lendo apenas os dados relevantes.</li>
<li>A inclus√£o de <code>data_transacao DESC</code> no √≠ndice tamb√©m satisfaz a cl√°usula <code>ORDER BY</code> diretamente, eliminando completamente a necessidade de uma opera√ß√£o de <code>Sort</code> (especialmente o lento "external merge Disk").</li>
<li>A coluna <code>valor</code> tamb√©m √© coberta pelo √≠ndice, ajudando a filtrar ainda mais cedo ou garantindo que o √≠ndice seja um "covering index" para parte das colunas da query.</li>
</ul>
Isso resulta em um plano de execu√ß√£o extremamente eficiente, transformando o tempo de resposta da query!`;

            feedbackHtml = `
                <h3>üéâ SUCESSO! üéâ</h3>
                <p><strong>An√°lise da Sua Solu√ß√£o:</strong></p>
                <p class="metric"><strong>Tempo de Execu√ß√£o Estimado (AP√ìS SUA OTIMIZA√á√ÉO):</strong> <span class="highlight">0.18 segundos</span> (redu√ß√£o de 99.3%)</p>
                <p class="metric"><strong>Recursos Consumidos (I/O Disk):</strong> <span class="highlight">150 KB lidos</span> (redu√ß√£o de 99.9%)</p>
                <p class="metric"><strong>Uso de Mem√≥ria:</strong> <span class="highlight">Baixo</span></p>

                <details open>
                    <summary>Visualizar Sa√≠da do EXPLAIN ANALYZE (AP√ìS SUA OTIMIZA√á√ÉO - Simulada)</summary>
                    <div>
                        <pre><code>${optimizedExplain}</code></pre>
                    </div>
                </details>

                <details open>
                    <summary>Visualizar Descri√ß√£o do Plano (Interpreta√ß√£o do EXPLAIN ANALYZE)</summary>
                    <div>
                        <p>${optimizedPlanDescription}</p>
                    </div>
                </details>

                <p><strong>Parab√©ns!</strong> Voc√™ dominou o desafio de otimiza√ß√£o de escaneamento excessivo de dados no PostgreSQL!</p>
            `;
            feedbackDiv.className = 'feedback success';
        } else {
            feedbackHtml = `
                <h3>üòî Tente Novamente! üòî</h3>
                <p>Sua solu√ß√£o ainda n√£o atingiu o n√≠vel de otimiza√ß√£o esperado ou n√£o est√° no formato correto para este desafio.</p>
                <p>Reveja a sa√≠da do <code>EXPLAIN ANALYZE</code> original. O principal indicador de problema √© o <strong><code>Seq Scan on transacoes</code></strong>, que significa que o PostgreSQL est√° lendo a tabela inteira. Al√©m disso, observe o <strong><code>Sort Method: external merge Disk</code></strong>, que indica que a ordena√ß√£o est√° sendo feita em disco.</p>
                <p>Pense em como voc√™ pode ajudar o PostgreSQL a evitar o `Seq Scan` e o `Sort` em disco, considerando as colunas usadas nas cl√°usulas `WHERE` e `ORDER BY`.</p>
            `;
            feedbackDiv.className = 'feedback failure';
        }

        feedbackDiv.innerHTML = feedbackHtml;
        feedbackDiv.style.display = 'block';
        feedbackDiv.scrollIntoView({ behavior: 'smooth' });
    });
</script>
</body>
</html>