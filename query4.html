<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Desafio de Otimiza√ß√£o de Queries: PostgreSQL</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f4f7f6;
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        h1, h2 {
            color: #0056b3;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
            margin-top: 30px;
        }
        h1 {
            text-align: center;
            margin-bottom: 40px;
        }
        pre {
            background-color: #e8f0f7;
            border: 1px solid #cce0f0;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            color: #36454F;
        }
        code {
            font-family: 'Consolas', 'Monaco', monospace;
            background-color: #f0f0f0;
            padding: 2px 5px;
            border-radius: 4px;
        }
        .section {
            margin-bottom: 25px;
        }
        textarea {
            width: 100%;
            height: 150px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.95em;
            resize: vertical;
            box-sizing: border-box;
        }
        button {
            display: block;
            width: 200px;
            padding: 12px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin: 20px auto 0 auto;
        }
        button:hover {
            background-color: #0056b3;
        }
        .feedback {
            margin-top: 30px;
            padding: 20px;
            border-radius: 8px;
            display: none;
        }
        .feedback.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .feedback.failure {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .feedback.info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .feedback h3 {
            margin-top: 0;
            color: #0056b3;
        }
        .metric {
            margin-bottom: 5px;
        }
        .highlight {
            font-weight: bold;
            color: #0056b3;
        }
        /* Style for the details/summary elements */
        details {
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        summary {
            padding: 10px 15px;
            cursor: pointer;
            font-weight: bold;
            color: #0056b3;
            list-style: inside;
        }
        details > div {
            padding: 10px 15px 15px 15px;
            border-top: 1px solid #ddd;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Desafio de Otimiza√ß√£o de Queries: PostgreSQL</h1>

    <div class="section">
        <h2>Modelo de Dados:</h2>
        <p>Voc√™ gerencia uma grande tabela de produtos em um sistema de e-commerce. A coluna `descricao_longa` cont√©m descri√ß√µes detalhadas de texto livre para cada produto.</p>
        <pre><code>CREATE TABLE produtos (
    produto_id SERIAL PRIMARY KEY,
    nome_produto VARCHAR(255) NOT NULL,
    categoria VARCHAR(100),
    preco DECIMAL(10, 2),
    descricao_curta VARCHAR(500),
    descricao_longa TEXT, -- Pode conter strings muito grandes
    -- ... outras colunas
);</code></pre>
        <p><strong>Observa√ß√µes Importantes:</strong></p>
        <ul>
            <li>A tabela <code>produtos</code> tem <strong>milh√µes de registros</strong>.</li>
            <li>N√£o h√° √≠ndices espec√≠ficos para pesquisa de texto em `descricao_longa`.</li>
        </ul>
    </div>

    <div class="section">
        <h2>Query Problem√°tica:</h2>
        <p>A equipe de marketing precisa encontrar produtos cuja descri√ß√£o longa contenha termos espec√≠ficos, independentemente da posi√ß√£o do termo na descri√ß√£o. A query atual est√° extremamente lenta.</p>
        <pre><code>SELECT
    produto_id,
    nome_produto,
    descricao_curta
FROM
    produtos
WHERE
    descricao_longa ILIKE '%melhoria de performance%';
</code></pre>
    </div>

    <div class="section">
        <h2>An√°lise de Performance Original (Simulada - PostgreSQL):</h2>
        <p class="metric"><strong>Tempo de Execu√ß√£o Estimado:</strong> <span class="highlight">48 segundos</span></p>
        <p class="metric"><strong>Recursos Consumidos (I/O Disk):</strong> <span class="highlight">20 GB lidos</span></p>
        <p class="metric"><strong>Uso de CPU:</strong> <span class="highlight">Extremamente Alto</span></p>

        <details>
            <summary>Visualizar Sa√≠da do EXPLAIN ANALYZE (Simulada)</summary>
            <div>
                    <pre><code>
                                            QUERY PLAN
--------------------------------------------------------------------------------------------------
 Seq Scan on produtos  (cost=0.00..850000.00 rows=100 width=120) (actual time=0.080..47900.500 rows=50 loops=1)
   Filter: (descricao_longa ~~* '%melhoria de performance%'::text)
   Rows Removed by Filter: 5000000
   Buffers: shared hit=1000000 read=2000000
   Planning Time: 0.123 ms
   Execution Time: 47900.789 ms
(6 rows)
                    </code></pre>
            </div>
        </details>

        <details>
            <summary>Visualizar Descri√ß√£o do Plano (Interpreta√ß√£o do EXPLAIN ANALYZE)</summary>
            <div>
                <p>O <code>EXPLAIN ANALYZE</code> claramente indica um **<code>Seq Scan on produtos</code>**. Isso significa que o PostgreSQL est√° varrendo a tabela `produtos` inteira (milh√µes de registros) para cada execu√ß√£o da query. O operador <code>~~*</code> √© o `ILIKE` (case-insensitive `LIKE`).</p>
                <p>O wildcard inicial (`%`) na cl√°usula `ILIKE '%termo%'` impede que um √≠ndice B-tree tradicional na coluna `descricao_longa` seja utilizado. O PostgreSQL precisa ler cada linha da tabela e aplicar a compara√ß√£o de padr√£o na descri√ß√£o completa, o que √© computacionalmente muito intensivo para grandes volumes de texto e dados.</p>
                <p>O alto tempo de execu√ß√£o e o alto consumo de I/O e CPU s√£o diretamente atribu√≠veis a este `Seq Scan` n√£o otimizado para pesquisa de texto livre.</p>
            </div>
        </details>
    </div>

    <div class="section">
        <h2>Sua Miss√£o:</h2>
        <p>Analise a query, o modelo de dados e a sa√≠da do <code>EXPLAIN ANALYZE</code>. Identifique o(s) problema(s) de performance causado(s) pela pesquisa de texto livre e o(s) gargalo(s) principal(is). Proponha uma ou mais instru√ß√µes SQL que otimizem drasticamente a performance desta query.</p>
    </div>

    <div class="section">
        <h3>Caixa de Texto para Solu√ß√£o:</h3>
        <textarea id="solutionInput" placeholder="-- Insira sua solu√ß√£o SQL aqui (ex: CREATE INDEX, ajuste na query, etc.)"></textarea>
        <button id="submitButton">Submeter Melhoria</button>
    </div>

    <div id="feedback" class="feedback">
    </div>

    <details class="section">
        <summary>Visualizar Solu√ß√£o Sugerida</summary>
        <div>
            <h3>Solu√ß√£o de √çndice (Full-Text Search):</h3>
            <pre><code>-- 1. Adicionar uma coluna de tsvector para otimiza√ß√£o de busca
ALTER TABLE produtos ADD COLUMN descricao_fts TSVECTOR;

-- 2. Criar um √≠ndice GIN na nova coluna para pesquisa eficiente
CREATE INDEX idx_produtos_descricao_fts ON produtos USING GIN (descricao_fts);

-- 3. Criar um trigger para manter 'descricao_fts' atualizada automaticamente
--    (Para um treinamento, voc√™ pode simplificar e apenas mencionar a necessidade)
--    Exemplo simples (requer configurar o dicion√°rio apropriado):
-- CREATE FUNCTION update_descricao_fts_trigger() RETURNS TRIGGER AS $$
-- BEGIN
--   NEW.descricao_fts := to_tsvector('portuguese', NEW.descricao_longa);
--   RETURN NEW;
-- END
-- $$ LANGUAGE plpgsql;
-- CREATE TRIGGER trg_produtos_descricao_fts
-- BEFORE INSERT OR UPDATE ON produtos
-- FOR EACH ROW EXECUTE FUNCTION update_descricao_fts_trigger();

-- 4. Popular a coluna para dados existentes (ap√≥s criar a coluna e o trigger/fun√ß√£o)
UPDATE produtos SET descricao_fts = to_tsvector('portuguese', descricao_longa);
</code></pre>
            <h3>Query Otimizada:</h3>
            <pre><code>SELECT
    produto_id,
    nome_produto,
    descricao_curta
FROM
    produtos
WHERE
    descricao_fts @@ to_tsquery('portuguese', 'melhoria &amp; performance');
-- Ou para m√∫ltiplas palavras OR:
-- WHERE descricao_fts @@ to_tsquery('portuguese', 'melhoria | performance');
</code></pre>
            <h4>Explica√ß√£o da Solu√ß√£o:</h4>
            <p>O problema era a inefici√™ncia do `ILIKE '%termo%'` com wildcard inicial, que for√ßa um `Seq Scan`. Para pesquisa de texto livre em grandes volumes de dados no PostgreSQL, a solu√ß√£o ideal √© usar as funcionalidades de **Full-Text Search (FTS)**.</p>
            <p>A solu√ß√£o envolve os seguintes passos:</p>
            <ul>
                <li><strong>`TSVECTOR` e `to_tsvector()`:</strong> Cria-se uma nova coluna do tipo `TSVECTOR` (um tipo de dado otimizado para FTS). A fun√ß√£o `to_tsvector()` converte o texto da `descricao_longa` em um `tsvector`, que √© uma representa√ß√£o processada e otimizada para busca (normaliza palavras, remove stopwords, etc.). √â importante especificar o dicion√°rio de idiomas (`'portuguese'`) para um tratamento correto.</li>
                <li><strong>√çndice `GIN`:</strong> Um √≠ndice `GIN` (Generalized Inverted Index) √© criado na coluna `TSVECTOR`. √çndices `GIN` s√£o altamente eficientes para pesquisar por ocorr√™ncias de termos em valores de texto (como em FTS). Eles permitem que o PostgreSQL localize rapidamente as linhas que cont√™m os termos da busca, evitando o `Seq Scan`.</li>
                <li><strong>Manuten√ß√£o Autom√°tica (Trigger):</strong> Para garantir que a coluna `descricao_fts` esteja sempre atualizada quando `descricao_longa` √© inserida ou modificada, um `TRIGGER` (com uma fun√ß√£o PL/pgSQL) deve ser configurado.</li>
                <li><strong>`to_tsquery()` e operador `@@`:</strong> A query √© modificada para usar `to_tsquery()` para converter o termo de busca em um `tsquery` (formato de busca otimizado) e o operador `@@` para performar a busca de FTS usando o √≠ndice `GIN`. Note que o `&` √© para "AND" e `|` para "OR" entre os termos.</li>
            </ul>
            <p>Esta abordagem permite que o PostgreSQL utilize o √≠ndice `GIN` de forma extremamente eficiente, transformando a pesquisa de texto livre de um `Seq Scan` caro em um `Index Scan` r√°pido e perform√°tico.</p>
        </div>
    </details>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const submitButton = document.getElementById('submitButton');
        const solutionInput = document.getElementById('solutionInput');
        const feedbackDiv = document.getElementById('feedback');

        submitButton.addEventListener('click', () => {
            const solution = solutionInput.value.trim();
            let feedbackHtml = '';
            let isSuccess = false;

            // Normalize solution string for comparison.
            const submittedSolutionCleaned = solution.toLowerCase()
                                                    .replace(/\s+/g, ' ') // Replace multiple spaces with single space
                                                    .replace(/;/g, '')    // Remove semicolons
                                                    .trim();

            // --- Valida√ß√£o de Sintaxe SQL Gen√©rica (N√≠vel 1) ---
            const genericSqlPattern = /^(select|insert|update|delete|create|alter|drop|with|explain|vacuum|analyze|reindex|set|show)\s/i;
            const hasParen = submittedSolutionCleaned.includes("(") && submittedSolutionCleaned.includes(")");
            const hasFromOrOn = submittedSolutionCleaned.includes(" from ") || submittedSolutionCleaned.includes(" on ");
            const hasWhereOrGroup = submittedSolutionCleaned.includes(" where ") || submittedSolutionCleaned.includes(" group by ");
            const isMeaningfullyLong = submittedSolutionCleaned.length > 5;

            const isLikelyValidSql = genericSqlPattern.test(submittedSolutionCleaned) ||
                                     (isMeaningfullyLong && (hasParen || hasFromOrOn || hasWhereOrGroup || submittedSolutionCleaned.includes("=")));

            if (!isLikelyValidSql) {
                feedbackHtml = `
                    <h3>üö´ ERRO: Sintaxe SQL Inv√°lida!</h3>
                    <p>Sua submiss√£o n√£o parece ser uma instru√ß√£o SQL v√°lida.</p>
                    <p>Por favor, verifique a sintaxe geral do seu comando SQL. Exemplo: <code>CREATE INDEX...</code>, <code>SELECT...</code>, <code>ALTER TABLE...</code>.</p>
                    <p>O comando submetido foi: <pre><code>${solution}</code></pre></p>
                `;
                feedbackDiv.className = 'feedback failure';
                feedbackDiv.innerHTML = feedbackHtml;
                feedbackDiv.style.display = 'block';
                feedbackDiv.scrollIntoView({ behavior: 'smooth' });
                return;
            }

            // --- Valida√ß√£o do Tipo de Comando Esperado para a Solu√ß√£o (N√≠vel 2) ---
            // For this challenge, we expect a combination of ALTER TABLE/CREATE INDEX AND a SELECT query.
            // We'll check for the key components across the *entire submitted text*.

            const isExpectedAlterCommand = submittedSolutionCleaned.includes("alter table") && submittedSolutionCleaned.includes("add column") && submittedSolutionCleaned.includes("tsvector");
            const isExpectedCreateIndexCommand = submittedSolutionCleaned.includes("create index") && submittedSolutionCleaned.includes("using gin") && submittedSolutionCleaned.includes("tsvector");
            const isExpectedSelectCommand = submittedSolutionCleaned.includes("select") && submittedSolutionCleaned.includes("from produtos") && submittedSolutionCleaned.includes("tsvector @@ to_tsquery");

            const isCorrectType = isExpectedAlterCommand || isExpectedCreateIndexCommand || isExpectedSelectCommand;

            if (!isCorrectType) {
                 feedbackHtml = `
                    <h3>ü§î Comando V√°lido, Mas Inesperado para Este Desafio!</h3>
                    <p>Sua submiss√£o √© uma instru√ß√£o SQL v√°lida, mas **n√£o √© o tipo de comando esperado para otimizar este problema de performance**.</p>
                    <p>Para este desafio, esperamos uma solu√ß√£o que envolva a configura√ß√£o de **Full-Text Search** no PostgreSQL (adicionar coluna TSVECTOR, criar √≠ndice GIN e usar uma query com <code>@@ to_tsquery</code>).</p>
                    <p>O comando submetido foi: <pre><code>${solution}</code></pre></p>
                `;
                feedbackDiv.className = 'feedback failure';
                feedbackDiv.innerHTML = feedbackHtml;
                feedbackDiv.style.display = 'block';
                feedbackDiv.scrollIntoView({ behavior: 'smooth' });
                return;
            }

            // --- Valida√ß√£o da Efic√°cia da Solu√ß√£o (N√≠vel 3: L√≥gica espec√≠fica do desafio) ---
            // Check if all core components of the FTS solution are present
            const hasTsvectorColumnCreation = submittedSolutionCleaned.includes("alter table produtos add column") && submittedSolutionCleaned.includes("tsvector");
            const hasGinIndexCreation = submittedSolutionCleaned.includes("create index") && submittedSolutionCleaned.includes("on produtos") && submittedSolutionCleaned.includes("using gin") && submittedSolutionCleaned.includes("tsvector");
            const hasOptimizedFtsQuery = submittedSolutionCleaned.includes("select") && submittedSolutionCleaned.includes("from produtos") && submittedSolutionCleaned.includes("descricao_fts @@ to_tsquery") && (submittedSolutionCleaned.includes("'portuguese'") || submittedSolutionCleaned.includes("'english'")); // Check for language

            // A user might submit parts. For success, we require the core setup AND the optimized query.
            // It's acceptable for the user to submit multiple commands in the textarea.
            if (hasTsvectorColumnCreation && hasGinIndexCreation && hasOptimizedFtsQuery) {
                isSuccess = true;
                const optimizedExplain = `
                                        QUERY PLAN
--------------------------------------------------------------------------------------------------
Bitmap Heap Scan on produtos  (cost=12.50..80.70 rows=50 width=120) (actual time=0.800..2.500 rows=50 loops=1)
Recheck Cond: (descricao_fts @@ to_tsquery('portuguese'::regconfig, 'melhoria & performance'::text))
Buffers: shared hit=20
->  Bitmap Index Scan on idx_produtos_descricao_fts  (cost=0.00..12.45 rows=50 width=0) (actual time=0.500..0.550 loops=1)
     Index Cond: (descricao_fts @@ to_tsquery('portuguese'::regconfig, 'melhoria & performance'::text))
     Buffers: shared hit=5
(7 rows)
                `;
                const optimizedPlanDescription = `Voc√™ identificou e resolveu o problema do \`ILIKE '%termo%'\` ineficiente! O <code>EXPLAIN ANALYZE</code> original mostrava um caro <code>Seq Scan</code>.

Sua solu√ß√£o de utilizar as funcionalidades de **Full-Text Search (FTS) do PostgreSQL** √© a abordagem correta.
<ul>
<li>A cria√ß√£o de uma coluna <code>TSVECTOR</code> e seu preenchimento via \`to_tsvector()\` pr√©-processa o texto para buscas.</li>
<li>O **√≠ndice \`GIN\`** na coluna \`TSVECTOR\` permite que o PostgreSQL localize eficientemente os produtos que cont√™m os termos de busca, transformando o \`Seq Scan\` em um r√°pido \`Bitmap Index Scan\`.</li>
<li>A query otimizada usando \`to_tsquery()\` e o operador \`@@\` garante que o √≠ndice \`GIN\` seja utilizado de forma eficiente.</li>
</ul>
Esta abordagem √© fundamental para pesquisas de texto livre escal√°veis no PostgreSQL, resultando em uma melhoria dr√°stica no tempo de execu√ß√£o e consumo de recursos.`;

                feedbackHtml = `
                    <h3>üéâ SUCESSO! üéâ</h3>
                    <p><strong>An√°lise da Sua Solu√ß√£o:</strong></p>
                    <p class="metric"><strong>Tempo de Execu√ß√£o Estimado (AP√ìS SUA OTIMIZA√á√ÉO):</strong> <span class="highlight">0.05 segundos</span> (redu√ß√£o de 99.9%)</p>
                    <p class="metric"><strong>Recursos Consumidos (I/O Disk):</strong> <span class="highlight">Alguns KB lidos</span> (redu√ß√£o de 99.9%)</p>
                    <p class="metric"><strong>Uso de CPU:</strong> <span class="highlight">Baixo</span></p>

                    <details open>
                        <summary>Visualizar Sa√≠da do EXPLAIN ANALYZE (AP√ìS SUA OTIMIZA√á√ÉO - Simulada)</summary>
                        <div>
                            <pre><code>${optimizedExplain}</code></pre>
                        </div>
                    </details>

                    <details open>
                        <summary>Visualizar Descri√ß√£o do Plano (Interpreta√ß√£o do EXPLAIN ANALYZE)</summary>
                        <div>
                            <p>${optimizedPlanDescription}</p>
                        </div>
                    </details>

                    <p><strong>Parab√©ns!</strong> Voc√™ dominou o desafio de otimiza√ß√£o de pesquisas de texto livre no PostgreSQL!</p>
                `;
                feedbackDiv.className = 'feedback success';
            } else {
                // Command is CREATE INDEX/ALTER TABLE/SELECT, but not the complete/optimal FTS solution
                feedbackHtml = `
                    <h3>üòî Comando Incorreto para Otimiza√ß√£o! üòî</h3>
                    <p>Sua solu√ß√£o √© uma instru√ß√£o SQL v√°lida, mas **n√£o abordou o problema de performance de forma eficaz** ou n√£o seguiu a estrat√©gia ideal para Full-Text Search neste desafio.</p>
                    <p>Lembre-se que a solu√ß√£o de Full-Text Search no PostgreSQL envolve m√∫ltiplas etapas: <strong>adicionar uma coluna TSVECTOR</strong>, <strong>criar um √≠ndice GIN</strong> nessa coluna e **modificar a query** para usar operadores e fun√ß√µes de FTS (<code>@@ to_tsquery()</code>).</p>
                    <p>O comando submetido foi: <pre><code>${solution}</code></pre></p>
                `;
                feedbackDiv.className = 'feedback failure';
            }

            feedbackDiv.innerHTML = feedbackHtml;
            feedbackDiv.style.display = 'block';
            feedbackDiv.scrollIntoView({ behavior: 'smooth' });
        });
    });
</script>
</body>
</html>